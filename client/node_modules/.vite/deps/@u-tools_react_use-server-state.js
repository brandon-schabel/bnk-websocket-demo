import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@u-tools/core/modules/server-factory/create-state-dispatchers.ts
function isArrayType(input) {
  return Array.isArray(input);
}
function isObjectType(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input);
}
function isNumberType(input) {
  return typeof input === "number";
}
function createArrayDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    push: (value, opts) => {
      const existingState = state || [];
      const newArr = [...existingState, value];
      updateFunction(key, newArr, opts);
    },
    pop: (opts) => {
      const newArr = state.slice(0, -1);
      updateFunction(key, newArr, opts);
    },
    insert: (index, value, opts) => {
      const newArr = [...state];
      newArr.splice(index, 0, value);
      updateFunction(key, newArr, opts);
    }
  };
}
function isBooleanType(input) {
  return typeof input === "boolean";
}
function createBooleanDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    toggle: (opts) => {
      updateFunction(key, !state, opts);
    }
  };
}
function createObjectDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    update: (value, opts) => {
      const newValue = { ...state, ...value };
      updateFunction(key, newValue, opts);
    }
  };
}
function createNumberDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    increment: (amount = 1, opts) => {
      updateFunction(key, state + amount, opts);
    },
    decrement: (amount = 1, opts) => {
      updateFunction(key, state - amount, opts);
    }
  };
}
function createDefaultDispatchers(key, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    }
  };
}
function mergeWithDefault(defaultState, state) {
  const mergedState = {};
  const missingKeys = [];
  for (const key in defaultState) {
    if (key in state) {
      mergedState[key] = state[key];
    } else {
      mergedState[key] = defaultState[key];
      missingKeys.push(key);
    }
  }
  if (missingKeys.length > 0) {
    console.info("Missing keys from state:", missingKeys.join(", "));
  }
  return mergedState;
}
function createStateDispatchers({
  defaultState,
  state,
  updateFunction
}) {
  const mergedState = mergeWithDefault(defaultState, state);
  return Object.keys(mergedState).reduce((acc, key) => {
    const k = key;
    const currentValue = mergedState[k];
    if (isArrayType(currentValue)) {
      acc[k] = createArrayDispatchers(k, currentValue, updateFunction);
    } else if (isObjectType(currentValue)) {
      acc[k] = createObjectDispatchers(k, currentValue, updateFunction);
    } else if (isNumberType(currentValue)) {
      acc[k] = createNumberDispatchers(k, currentValue, updateFunction);
    } else if (isBooleanType(currentValue)) {
      acc[k] = createBooleanDispatchers(k, currentValue, updateFunction);
    } else {
      acc[k] = createDefaultDispatchers(k, updateFunction);
    }
    return acc;
  }, {});
}

// node_modules/@u-tools/react/use-server-state.ts
var import_react = __toESM(require_react());
var MAX_RETRIES = 5;
var getAppStateFromLocalStorage = (defaultState) => {
  const appStateString = localStorage.getItem("appState");
  try {
    const storedState = appStateString ? JSON.parse(appStateString) : {};
    return { ...defaultState, ...storedState };
  } catch (error) {
    return defaultState;
  }
};
function useServerState({
  defaultState,
  url,
  optimisticMap
}) {
  const [state, setState] = (0, import_react.useState)(
    () => getAppStateFromLocalStorage(defaultState)
  );
  const wsRef = (0, import_react.useRef)(null);
  const initialized = (0, import_react.useRef)(false);
  const prevStateRef = (0, import_react.useRef)(null);
  const retryCount = (0, import_react.useRef)(0);
  (0, import_react.useEffect)(() => {
    const connectToServer = () => {
      const websocket = new WebSocket(url);
      wsRef.current = websocket;
      websocket.onopen = () => {
        retryCount.current = 0;
      };
      websocket.onmessage = (event) => {
        if (typeof event.data !== "string")
          return;
        const receivedData = JSON.parse(event.data);
        if (receivedData.status === "failure" && prevStateRef.current) {
          setState(prevStateRef.current);
        } else if (receivedData.key && "value" in receivedData) {
          setState((prevState) => ({
            ...prevState,
            [receivedData.key]: receivedData.value
          }));
        }
      };
      websocket.onclose = (event) => {
        if (event.code !== 1e3 && retryCount.current < MAX_RETRIES) {
          retryCount.current += 1;
          const delay = Math.min(1e3 * retryCount.current, 3e4);
          setTimeout(connectToServer, delay);
        } else {
          retryCount.current = 0;
        }
      };
      return () => {
        var _a;
        (_a = websocket == null ? void 0 : websocket.close) == null ? void 0 : _a.call(websocket);
      };
    };
    connectToServer();
    return () => {
      var _a;
      (_a = wsRef.current) == null ? void 0 : _a.close();
    };
  }, [url]);
  (0, import_react.useEffect)(() => {
    const storedState = getAppStateFromLocalStorage(defaultState);
    if (!initialized.current) {
      setState(storedState);
      initialized.current = true;
      return;
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (initialized.current) {
      localStorage.setItem("appState", JSON.stringify(state));
    }
  }, [state]);
  const sendToServer = (key, value) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({ key, value }));
    }
  };
  const dispatch = (key, value, opts) => {
    const isOptimistic = (opts == null ? void 0 : opts.optimistic) ?? (optimisticMap == null ? void 0 : optimisticMap[key]) !== false;
    if (isOptimistic) {
      prevStateRef.current = state;
      setState((prev) => ({ ...prev, [key]: value }));
    }
    sendToServer(key, value);
  };
  const control = createStateDispatchers({
    defaultState,
    state,
    updateFunction: dispatch
  });
  return {
    state,
    control,
    dispatch
  };
}
export {
  useServerState
};
//# sourceMappingURL=@u-tools_react_use-server-state.js.map
