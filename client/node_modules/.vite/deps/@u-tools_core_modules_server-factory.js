import "./chunk-UXIASGQL.js";

// ../server/node_modules/@u-tools/core/modules/server-factory/body-parser-middleware.ts
var parsedBodies = /* @__PURE__ */ new WeakMap();
var bodyParserMiddleware = async (request, next) => {
  const contentType = request.headers.get("Content-Type");
  console.log({ contentType });
  if (contentType && contentType.includes("application/json")) {
    const rawBody = await request.text();
    try {
      const parsed = JSON.parse(rawBody);
      parsedBodies.set(request, parsed);
    } catch (error) {
      console.error("Failed to parse JSON body:", error);
    }
  } else {
    parsedBodies.set(request, await request.text());
  }
  return next();
};
function getParsedBody(request) {
  return parsedBodies.get(request);
}

// ../server/node_modules/@u-tools/core/modules/server-factory/create-cors-middleware.ts
var createCorsMiddleware = (options) => {
  const defaultMethods = ["GET", "POST", "PUT", "DELETE"];
  const defaultHeaders = ["Content-Type"];
  let allowedOrigins = options == null ? void 0 : options.allowedOrigins;
  if (options == null ? void 0 : options.allAllOrigins) {
    allowedOrigins = ["*"];
  }
  const allowedMethods = (options == null ? void 0 : options.allowedMethods) || defaultMethods;
  const allowedHeaders = (options == null ? void 0 : options.allowedHeaders) || defaultHeaders;
  return async (request, next) => {
    console.log("middleware running");
    console.log({
      headers: request.headers,
      request,
      options,
      allowedOrigins
    });
    const requestOrigin = request.headers.get("Origin");
    if (!requestOrigin) {
      console.error("Request does not have an Origin header.");
      return new Response("Bad Request: Missing Origin header.", {
        status: 400
      });
    }
    if (!(allowedOrigins == null ? void 0 : allowedOrigins.includes("*")) && !(allowedOrigins == null ? void 0 : allowedOrigins.includes(requestOrigin))) {
      console.error(`Origin ${requestOrigin} is not allowed.`);
      return new Response(
        `CORS Error: Origin ${requestOrigin} is not allowed.`,
        { status: 403 }
      );
    }
    if (request.method === "OPTIONS") {
      const requestMethod = request.headers.get(
        "Access-Control-Request-Method"
      );
      if (requestMethod && !allowedMethods.includes(requestMethod)) {
        console.error(`Method ${requestMethod} is not allowed.`);
        return new Response(
          `CORS Error: Method ${requestMethod} is not allowed.`,
          { status: 405 }
        );
      }
      let response2 = new Response(null, { status: 204 });
      response2.headers.set("Access-Control-Allow-Origin", requestOrigin);
      response2.headers.set(
        "Access-Control-Allow-Methods",
        allowedMethods.join(", ")
      );
      response2.headers.set(
        "Access-Control-Allow-Headers",
        allowedHeaders.join(", ")
      );
      console.log(response2);
      return response2;
    }
    const response = await next();
    response.headers.set("Access-Control-Allow-Origin", requestOrigin);
    response.headers.set(
      "Access-Control-Allow-Methods",
      allowedMethods.join(", ")
    );
    response.headers.set(
      "Access-Control-Allow-Headers",
      allowedHeaders.join(", ")
    );
    console.log(response);
    return response;
  };
};

// ../server/node_modules/@u-tools/core/modules/server-factory/create-state-dispatchers.ts
function isArrayType(input) {
  return Array.isArray(input);
}
function isObjectType(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input);
}
function isNumberType(input) {
  return typeof input === "number";
}
function createArrayDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    push: (value, opts) => {
      const existingState = state || [];
      const newArr = [...existingState, value];
      updateFunction(key, newArr, opts);
    },
    pop: (opts) => {
      const newArr = state.slice(0, -1);
      updateFunction(key, newArr, opts);
    },
    insert: (index, value, opts) => {
      const newArr = [...state];
      newArr.splice(index, 0, value);
      updateFunction(key, newArr, opts);
    }
  };
}
function isBooleanType(input) {
  return typeof input === "boolean";
}
function createBooleanDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    toggle: (opts) => {
      updateFunction(key, !state, opts);
    }
  };
}
function createObjectDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    update: (value, opts) => {
      const newValue = { ...state, ...value };
      updateFunction(key, newValue, opts);
    }
  };
}
function createNumberDispatchers(key, state, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    },
    increment: (amount = 1, opts) => {
      updateFunction(key, state + amount, opts);
    },
    decrement: (amount = 1, opts) => {
      updateFunction(key, state - amount, opts);
    }
  };
}
function createDefaultDispatchers(key, updateFunction) {
  return {
    set: (value, opts) => {
      updateFunction(key, value, opts);
    }
  };
}
function mergeWithDefault(defaultState, state) {
  const mergedState = {};
  const missingKeys = [];
  for (const key in defaultState) {
    if (key in state) {
      mergedState[key] = state[key];
    } else {
      mergedState[key] = defaultState[key];
      missingKeys.push(key);
    }
  }
  if (missingKeys.length > 0) {
    console.info("Missing keys from state:", missingKeys.join(", "));
  }
  return mergedState;
}
function createStateDispatchers({
  defaultState,
  state,
  updateFunction
}) {
  const mergedState = mergeWithDefault(defaultState, state);
  return Object.keys(mergedState).reduce((acc, key) => {
    const k = key;
    const currentValue = mergedState[k];
    if (isArrayType(currentValue)) {
      acc[k] = createArrayDispatchers(k, currentValue, updateFunction);
    } else if (isObjectType(currentValue)) {
      acc[k] = createObjectDispatchers(k, currentValue, updateFunction);
    } else if (isNumberType(currentValue)) {
      acc[k] = createNumberDispatchers(k, currentValue, updateFunction);
    } else if (isBooleanType(currentValue)) {
      acc[k] = createBooleanDispatchers(k, currentValue, updateFunction);
    } else {
      acc[k] = createDefaultDispatchers(k, updateFunction);
    }
    return acc;
  }, {});
}

// ../server/node_modules/@u-tools/core/modules/server-factory/create-web-socket-state-machine.tsx
var createWSStateMachine = (initialState) => {
  const connectedClients = /* @__PURE__ */ new Set();
  let currentState = initialState;
  const stateChangeCallbacks = {};
  function onStateChange(key, callback) {
    var _a;
    console.log({
      key,
      callback
    });
    if (!stateChangeCallbacks[key]) {
      stateChangeCallbacks[key] = [];
    }
    (_a = stateChangeCallbacks == null ? void 0 : stateChangeCallbacks[key]) == null ? void 0 : _a.push(callback);
  }
  const websocketHandler = {
    open: (ws) => {
      connectedClients.add(ws);
    },
    close: (ws) => {
      connectedClients.delete(ws);
    },
    message: (_ws, msg) => {
      if (typeof msg !== "string")
        return;
      const data = JSON.parse(msg);
      console.log({ data });
      if (data.key in currentState) {
        updateStateAndDispatch(data.key, data.value);
      }
    }
  };
  function updateStateAndDispatch(key, updater) {
    var _a;
    const newValue = typeof updater === "function" ? updater(
      currentState[key]
    ) : updater;
    currentState[key] = newValue;
    (_a = stateChangeCallbacks[key]) == null ? void 0 : _a.forEach((callback) => callback(newValue));
    const updatedStateData = {
      key,
      value: newValue
    };
    console.log({
      newValue,
      updatedStateData
    });
    for (const client of connectedClients) {
      client.send(JSON.stringify(updatedStateData));
    }
  }
  const dispatchers = createStateDispatchers(
    {
      defaultState: initialState,
      state: currentState,
      updateFunction: updateStateAndDispatch
    }
    // initialState,
    // updateStateAndDispatch
  );
  return {
    updateStateAndDispatch,
    websocketHandler,
    connectedClients,
    state: currentState,
    control: dispatchers,
    onStateChange
  };
};

// ../server/node_modules/@u-tools/core/modules/server-factory/handle-file-upload.ts
async function handleFileUpload({
  request,
  path
}) {
  var _a;
  const file = Bun.file(path);
  if (await (file == null ? void 0 : file.exists()) === true) {
    console.log("file already exists");
    return path;
  }
  const reader = (_a = request == null ? void 0 : request.body) == null ? void 0 : _a.getReader();
  file.writer().start;
  while (true) {
    const readerData = await (reader == null ? void 0 : reader.read());
    if (!readerData) {
      console.error("handleFileUpload", "readerData nto found");
      break;
    }
    const { done, value } = readerData;
    if (done)
      break;
    file.writer(value);
  }
  file.writer().end;
  return path;
}

// ../server/node_modules/@u-tools/core/modules/server-factory/check-file-size-middleware.ts
function checkFileSizeMiddleware(maxSize) {
  return (request, next) => {
    if (Number(request.headers.get("Content-Length")) > maxSize) {
      return new Response("File too large", { status: 413 });
    }
    return next();
  };
}

// ../server/node_modules/@u-tools/core/modules/server-factory/server-factory.ts
function createServerFactory({
  wsPaths,
  enableBodyParser,
  cors,
  maxFileSize
} = {
  wsPaths: [],
  enableBodyParser: true
}) {
  const routes = {};
  let server;
  let middlewares = [];
  if (cors) {
    middlewares.push(createCorsMiddleware(cors));
  }
  if (enableBodyParser) {
    middlewares.push(bodyParserMiddleware);
  }
  if (maxFileSize) {
    middlewares.push(checkFileSizeMiddleware(maxFileSize));
  }
  const middle = (middleware) => {
    middlewares.push(middleware);
  };
  const compose = (middlewares2, handler) => {
    return (request) => {
      const invokeHandler = (req, next) => handler(req);
      const finalMiddleware = middlewares2.reduceRight(
        (nextMiddleware, currentMiddleware) => {
          return (currentRequest) => {
            return currentMiddleware(
              currentRequest,
              () => nextMiddleware(currentRequest, () => handler(request))
            );
          };
        },
        invokeHandler
      );
      return finalMiddleware(request, () => handler(request));
    };
  };
  const handleError = (err, errorMessage, onErrorHandler, request) => {
    if (onErrorHandler) {
      return onErrorHandler(err, request);
    }
    console.error("Error processing request:", err);
    return new Response(errorMessage || "Internal Server Error", {
      status: 500
    });
  };
  const route = (routePath, options = {}) => {
    const { errorMessage, onError } = options;
    const defaultErrorMessage = "Internal Server Error";
    const onRequest = (handler) => {
      routes[routePath] = compose(middlewares, async (request) => {
        try {
          const parseQueryParams = () => {
            const url = new URL(request.url);
            return url.searchParams;
          };
          const parseHeaders = () => {
            return request.headers;
          };
          const getBody = async () => {
            return await getParsedBody(request);
          };
          const jsonRes = (body, options2) => {
            if (typeof body === "object") {
              return new Response(JSON.stringify(body), {
                headers: {
                  "Content-Type": "application/json",
                  ...options2 == null ? void 0 : options2.headers
                },
                ...options2
              });
            }
            return new Response(body, options2);
          };
          const htmlRes = (body, options2) => {
            return new Response(body, {
              headers: {
                "Content-Type": "text/html",
                ...options2 == null ? void 0 : options2.headers
              },
              ...options2
            });
          };
          return await handler({
            request,
            getBody,
            parseQueryParams,
            parseHeaders,
            jsonRes,
            htmlRes
          });
        } catch (error) {
          if (error instanceof Error) {
            return handleError(
              error,
              errorMessage || defaultErrorMessage,
              onError,
              request
            );
          } else {
            console.error("Caught a non-Error exception:", error);
            return new Response(errorMessage || defaultErrorMessage, {
              status: 500
            });
          }
        }
      });
    };
    return {
      onRequest
    };
  };
  const fetch = (request) => {
    const url = new URL(request.url);
    if (wsPaths == null ? void 0 : wsPaths.includes(url.pathname)) {
      const success = server.upgrade(request);
      return success ? void 0 : new Response("WebSocket upgrade error", { status: 400 });
    }
    const handler = routes[url.pathname];
    if (handler) {
      try {
        return handler(request);
      } catch (error) {
        console.error("Error processing request:", error);
        return new Response("Internal Server Error", { status: 500 });
      }
    } else {
      return new Response("404: Not Found", { status: 404 });
    }
  };
  const start = ({ port, hostname = "0.0.0.0", websocket, verbose } = {
    hostname: "0.0.0.0",
    port: 3e3,
    websocket: {
      message: () => {
        console.log("websocket msg");
      }
    },
    verbose: false
  }) => {
    try {
      if (verbose)
        console.log(`Starting server on port ${port}...`);
      server = Bun.serve({
        fetch,
        port,
        hostname,
        websocket: websocket || {
          message: () => {
            console.log("msg");
          }
        }
      });
      if (verbose)
        console.log(
          `Server started on port ${port}, press Ctrl+C to stop, http://${hostname}:${port}`
        );
      return server;
    } catch (error) {
      if (verbose)
        console.error("Error starting server:", error);
      throw error;
    }
  };
  return {
    middle,
    route,
    start
  };
}
export {
  bodyParserMiddleware as bodyParser,
  createCorsMiddleware,
  createServerFactory,
  createWSStateMachine,
  getParsedBody,
  handleFileUpload
};
//# sourceMappingURL=@u-tools_core_modules_server-factory.js.map
